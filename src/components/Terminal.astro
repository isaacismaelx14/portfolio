---
import { getLangFromUrl, useTranslations } from "../i18n/utils";
import { projects } from "../data/projects";
import { contactInfo } from "../data/about";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

// Prepare data for client-side
const projectsData = projects
    .filter(
        (p) =>
            p.featured ||
            p.title === "Project Templify" ||
            p.title === "Cominnek",
    )
    .map((p) => ({
        title: p.title,
        description: p.description[lang],
        link: p.link,
    }));

const aboutText = t("about.experienceList.wgsn.description"); // Use current role description as bio
---

<terminal-window
    data-projects={JSON.stringify(projectsData)}
    data-contact={JSON.stringify(contactInfo)}
    data-about={aboutText}
>
    <!-- Minimized Tab -->
    <div
        id="terminal-minimized"
        class="fixed bottom-0 right-8 z-[99] bg-[#1a1a1a] border-t border-x border-[#333] rounded-t-lg px-4 py-2 cursor-pointer transform translate-y-full transition-transform duration-300 flex items-center gap-2 hover:bg-[#252525]"
        role="button"
        aria-label="Restore Terminal"
    >
        <span class="text-[#33ff00] font-mono text-sm">>_ Terminal</span>
    </div>

    <!-- Terminal Overlay/Window -->
    <div
        id="terminal-overlay"
        class="fixed inset-0 z-[100] bg-black/50 hidden flex items-center justify-center p-4 backdrop-blur-sm transition-opacity duration-300"
        role="dialog"
        aria-modal="true"
        aria-label="Terminal Mode"
    >
        <div
            id="terminal-window"
            class="w-full max-w-4xl h-[80vh] bg-[#0c0c0c] rounded-lg shadow-2xl border border-[#333] flex flex-col font-mono overflow-hidden relative transition-all duration-300 transform scale-100 origin-bottom-right"
        >
            <!-- Matrix Canvas (Background) -->
            <canvas
                id="matrix-canvas"
                class="absolute inset-0 pointer-events-none opacity-10 hidden z-0"
            ></canvas>

            <!-- Terminal Header -->
            <div
                class="bg-[#1a1a1a] px-4 py-2 flex items-center justify-between border-b border-[#333] relative z-10 select-none"
            >
                <div class="flex items-center gap-2 group">
                    <!-- Close Button -->
                    <button
                        id="term-close"
                        class="w-3 h-3 rounded-full bg-[#ff5f56] flex items-center justify-center hover:bg-[#ff5f56]/80 transition-colors group-hover:opacity-100"
                        aria-label="Close"
                    >
                        <svg
                            class="w-2 h-2 text-black opacity-0 hover:opacity-100 transition-opacity"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="4"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        >
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                    <!-- Minimize Button -->
                    <button
                        id="term-minimize"
                        class="w-3 h-3 rounded-full bg-[#ffbd2e] flex items-center justify-center hover:bg-[#ffbd2e]/80 transition-colors group-hover:opacity-100"
                        aria-label="Minimize"
                    >
                        <svg
                            class="w-2 h-2 text-black opacity-0 hover:opacity-100 transition-opacity"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="4"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        >
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <!-- Maximize Button (Visual only) -->
                    <div class="w-3 h-3 rounded-full bg-[#27c93f]"></div>
                </div>
                <div
                    class="text-[#666] text-xs absolute left-1/2 transform -translate-x-1/2"
                >
                    isaac@portfolio:~
                </div>
            </div>

            <!-- Terminal Content -->
            <div
                id="terminal-content"
                class="flex-1 p-4 overflow-y-auto text-[#33ff00] text-sm md:text-base font-mono leading-relaxed relative z-10 cursor-text"
                style="text-shadow: 0 0 5px rgba(51, 255, 0, 0.5);"
            >
                <div id="terminal-output">
                    <div class="mb-4">
                        <p>Welcome to Terminal Mode v1.1.0</p>
                        <p>
                            Type <span class="text-white">'help'</span> to see available
                            commands.
                        </p>
                    </div>
                </div>

                <div
                    id="terminal-input-line"
                    class="flex items-center gap-2 mt-2"
                >
                    <span class="text-[#33ff00]">➜</span>
                    <span class="text-[#00ccff]">~</span>
                    <input
                        type="text"
                        id="terminal-input"
                        class="flex-1 bg-transparent border-none outline-none text-[#33ff00] placeholder-gray-700 caret-[#33ff00]"
                        autocomplete="off"
                        spellcheck="false"
                    />
                </div>
            </div>
        </div>
    </div>
</terminal-window>

<script>
    class TerminalWindow extends HTMLElement {
        // Elements
        private overlay: HTMLElement | null = null;
        private windowEl: HTMLElement | null = null;
        private minimizedTab: HTMLElement | null = null;
        private input: HTMLInputElement | null = null;
        private inputLine: HTMLElement | null = null;
        private output: HTMLElement | null = null;
        private content: HTMLElement | null = null;
        private canvas: HTMLCanvasElement | null = null;
        private closeBtn: HTMLElement | null = null;
        private minimizeBtn: HTMLElement | null = null;

        // State
        private isOpen = false;
        private isMinimized = false;
        private history: string[] = [];
        private historyIndex = -1;
        private matrixInterval: any = null;

        // Data
        private projects: any[] = [];
        private contactInfo: any = {};
        private aboutText: string = "";

        // Storage Keys
        private STORAGE_KEY_STATE = "terminal_state";
        private STORAGE_KEY_HISTORY = "terminal_history";
        private STORAGE_KEY_OUTPUT = "terminal_output";

        constructor() {
            super();
        }

        connectedCallback() {
            // Initialize elements
            this.overlay = this.querySelector("#terminal-overlay");
            this.windowEl = this.querySelector("#terminal-window");
            this.minimizedTab = this.querySelector("#terminal-minimized");
            this.input = this.querySelector("#terminal-input");
            this.inputLine = this.querySelector("#terminal-input-line");
            this.output = this.querySelector("#terminal-output");
            this.content = this.querySelector("#terminal-content");
            this.canvas = this.querySelector("#matrix-canvas");
            this.closeBtn = this.querySelector("#term-close");
            this.minimizeBtn = this.querySelector("#term-minimize");

            // Load Data
            try {
                this.projects = JSON.parse(this.dataset.projects || "[]");
                this.contactInfo = JSON.parse(this.dataset.contact || "{}");
                this.aboutText = this.dataset.about || "";
            } catch (e) {
                console.error("Error parsing terminal data", e);
            }

            // Restore State
            this.restoreState();

            // Bind events
            this.handleKeydown = this.handleKeydown.bind(this);
            this.handleInputKeydown = this.handleInputKeydown.bind(this);
            this.handleResize = this.handleResize.bind(this);
            this.openTerminal = this.openTerminal.bind(this);
            this.closeTerminal = this.closeTerminal.bind(this);
            this.minimizeTerminal = this.minimizeTerminal.bind(this);
            this.focusInput = this.focusInput.bind(this);

            // Add listeners
            window.addEventListener("keydown", this.handleKeydown);
            window.addEventListener("resize", this.handleResize);

            this.input?.addEventListener("keydown", this.handleInputKeydown);
            this.content?.addEventListener("click", this.focusInput);
            this.closeBtn?.addEventListener("click", this.closeTerminal);
            this.minimizeBtn?.addEventListener("click", this.minimizeTerminal);
            this.minimizedTab?.addEventListener("click", this.openTerminal);
        }

        disconnectedCallback() {
            // Clean up listeners
            window.removeEventListener("keydown", this.handleKeydown);
            window.removeEventListener("resize", this.handleResize);

            this.input?.removeEventListener("keydown", this.handleInputKeydown);
            this.content?.removeEventListener("click", this.focusInput);
            this.closeBtn?.removeEventListener("click", this.closeTerminal);
            this.minimizeBtn?.removeEventListener(
                "click",
                this.minimizeTerminal,
            );
            this.minimizedTab?.removeEventListener("click", this.openTerminal);

            this.stopMatrix();
        }

        private saveState() {
            const state = {
                isOpen: this.isOpen,
                isMinimized: this.isMinimized,
            };
            sessionStorage.setItem(
                this.STORAGE_KEY_STATE,
                JSON.stringify(state),
            );
            sessionStorage.setItem(
                this.STORAGE_KEY_HISTORY,
                JSON.stringify(this.history),
            );
            if (this.output) {
                sessionStorage.setItem(
                    this.STORAGE_KEY_OUTPUT,
                    this.output.innerHTML,
                );
            }
        }

        private restoreState() {
            try {
                // Restore History
                const savedHistory = sessionStorage.getItem(
                    this.STORAGE_KEY_HISTORY,
                );
                if (savedHistory) {
                    this.history = JSON.parse(savedHistory);
                    this.historyIndex = this.history.length;
                }

                // Restore Output
                const savedOutput = sessionStorage.getItem(
                    this.STORAGE_KEY_OUTPUT,
                );
                if (savedOutput && this.output) {
                    this.output.innerHTML = savedOutput;
                    // Scroll to bottom after restore
                    setTimeout(() => {
                        if (this.content)
                            this.content.scrollTop = this.content.scrollHeight;
                    }, 0);
                }

                // Restore UI State
                const savedState = sessionStorage.getItem(
                    this.STORAGE_KEY_STATE,
                );
                if (savedState) {
                    const { isOpen, isMinimized } = JSON.parse(savedState);
                    this.isOpen = isOpen;
                    this.isMinimized = isMinimized;

                    if (this.isOpen) {
                        if (this.isMinimized) {
                            // Restore in minimized state
                            this.minimizedTab?.classList.remove(
                                "translate-y-full",
                            );
                            this.overlay?.classList.add("hidden");
                            this.windowEl?.classList.add(
                                "scale-0",
                                "opacity-0",
                                "translate-y-[500px]",
                            );
                            this.windowEl?.classList.remove(
                                "scale-100",
                                "opacity-100",
                                "translate-y-0",
                            );
                        } else {
                            // Restore in open state
                            this.overlay?.classList.remove("hidden");
                            this.windowEl?.classList.remove(
                                "scale-0",
                                "opacity-0",
                                "translate-y-[500px]",
                            );
                            this.windowEl?.classList.add(
                                "scale-100",
                                "opacity-100",
                                "translate-y-0",
                            );
                            document.body.style.overflow = "hidden";
                            setTimeout(() => this.input?.focus(), 50);
                        }
                    }
                }
            } catch (e) {
                console.error("Error restoring terminal state", e);
            }
        }

        private handleKeydown(e: KeyboardEvent) {
            if ((e.metaKey || e.ctrlKey) && e.key === "k") {
                e.preventDefault();
                if (this.isOpen && !this.isMinimized) {
                    this.closeTerminal();
                } else {
                    this.openTerminal();
                }
                return;
            }

            if (!this.isOpen) return;

            // Game Controls (Window level)
            if (this.isGameActive) {
                if (e.ctrlKey && e.key === "c") {
                    this.stopGame("user");
                    e.preventDefault();
                    return;
                }
                if (e.key === "Escape") {
                    this.stopGame("user");
                    e.preventDefault();
                    return;
                }

                if (e.key === "ArrowUp" && this.direction !== "DOWN")
                    this.nextDirection = "UP";
                else if (e.key === "ArrowDown" && this.direction !== "UP")
                    this.nextDirection = "DOWN";
                else if (e.key === "ArrowLeft" && this.direction !== "RIGHT")
                    this.nextDirection = "LEFT";
                else if (e.key === "ArrowRight" && this.direction !== "LEFT")
                    this.nextDirection = "RIGHT";

                if (
                    [
                        "ArrowUp",
                        "ArrowDown",
                        "ArrowLeft",
                        "ArrowRight",
                    ].includes(e.key)
                ) {
                    e.preventDefault();
                }
                return;
            }

            if (this.isGameOver) {
                if (e.key.toLowerCase() === "r") {
                    this.startGame(this.gameDifficulty);
                    e.preventDefault();
                } else if (e.key.toLowerCase() === "q") {
                    this.isGameOver = false;
                    this.addToOutput("", "Game session ended.");
                    this.restorePrompt();
                    e.preventDefault();
                }
                return;
            }

            if (e.key === "Escape") {
                this.closeTerminal();
            }
        }

        private handleInputKeydown(e: KeyboardEvent) {
            if (e.key === "Enter") {
                if (this.input) {
                    this.handleCommand(this.input.value);
                }
            } else if (e.key === "ArrowUp") {
                e.preventDefault();
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    if (this.input)
                        this.input.value = this.history[this.historyIndex];
                }
            } else if (e.key === "ArrowDown") {
                e.preventDefault();
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    if (this.input)
                        this.input.value = this.history[this.historyIndex];
                } else {
                    this.historyIndex = this.history.length;
                    if (this.input) this.input.value = "";
                }
            }
        }

        private focusInput() {
            this.input?.focus();
        }

        private openTerminal() {
            if (!this.overlay || !this.windowEl) return;

            if (this.isMinimized) {
                this.minimizedTab?.classList.add("translate-y-full");
                this.overlay.classList.remove("hidden");
                setTimeout(() => {
                    this.windowEl?.classList.remove(
                        "scale-0",
                        "opacity-0",
                        "translate-y-[500px]",
                    );
                    this.windowEl?.classList.add(
                        "scale-100",
                        "opacity-100",
                        "translate-y-0",
                    );
                }, 50);
                this.isMinimized = false;
            } else {
                this.overlay.classList.remove("hidden");
                document.body.style.overflow = "hidden";
            }

            this.isOpen = true;
            this.saveState();
            // Small delay to ensure visibility before focus
            setTimeout(() => this.input?.focus(), 50);
        }

        private closeTerminal() {
            if (!this.overlay) return;
            this.overlay.classList.add("hidden");
            document.body.style.overflow = "";
            this.isOpen = false;
            this.isMinimized = false;
            this.minimizedTab?.classList.add("translate-y-full");

            // Clear Session
            sessionStorage.removeItem(this.STORAGE_KEY_STATE);
            sessionStorage.removeItem(this.STORAGE_KEY_HISTORY);
            sessionStorage.removeItem(this.STORAGE_KEY_OUTPUT);

            // Reset Internal State
            this.history = [];
            this.historyIndex = -1;
            if (this.output) {
                this.output.innerHTML = `
        <div class="mb-4">
          <p>Welcome to Terminal Mode v1.1.0</p>
          <p>Type <span class="text-white">'help'</span> to see available commands.</p>
        </div>`;
            }
        }

        private minimizeTerminal() {
            if (!this.overlay || !this.windowEl || !this.minimizedTab) return;

            this.windowEl.classList.remove(
                "scale-100",
                "opacity-100",
                "translate-y-0",
            );
            this.windowEl.classList.add(
                "scale-0",
                "opacity-0",
                "translate-y-[500px]",
            );

            setTimeout(() => {
                this.overlay?.classList.add("hidden");
                this.minimizedTab?.classList.remove("translate-y-full");
                document.body.style.overflow = "";
            }, 300);

            this.isMinimized = true;
            this.isOpen = true; // Still "open" but minimized
            this.saveState();
        }

        private handleCommand(cmdStr: string) {
            const trimmed = cmdStr.trim();
            if (!trimmed) return;

            this.history.push(trimmed);
            this.historyIndex = this.history.length;

            const [cmd, ...args] = trimmed.split(" ");

            // Routes map
            const routes: Record<string, string> = {
                "/": "Home",
                "/about": "About",
                "/projects": "Projects",
                "/contact": "Contact",
                "/changelog": "Changelog",
            };

            let result: string | void = "";

            switch (cmd.toLowerCase()) {
                case "help":
                    result = `
<div class="grid grid-cols-[100px_1fr] gap-2">
  <span class="text-white">ls</span>       <span>List available pages (routes)</span>
  <span class="text-white">cd [path]</span><span>Navigate to a page</span>
  <span class="text-white">about</span>    <span>Display information about Isaac</span>
  <span class="text-white">projects</span> <span>List key projects</span>
  <span class="text-white">contact</span>  <span>Show contact information</span>
  <span class="text-white">download</span> <span>Download Resume (PDF)</span>
  <span class="text-white">game</span>     <span>Play Snake</span>
  <span class="text-white">clear</span>    <span>Clear the terminal screen</span>
  <span class="text-white">matrix</span>   <span>Toggle Matrix rain effect</span>
  <span class="text-white">exit</span>     <span>Close terminal mode</span>
</div>`;
                    break;
                case "ls":
                    result = Object.entries(routes)
                        .map(
                            ([path, name]) =>
                                `<div class="text-[#00ccff]">${name} <span class="text-gray-500">(${path})</span></div>`,
                        )
                        .join("");
                    break;
                case "cd":
                    const path = args[0];
                    if (!path) {
                        result = `<span class="text-yellow-500">Usage: cd [path] (e.g., cd /projects)</span>`;
                    } else if (routes[path] || path === "..") {
                        // Handle .. basic support
                        if (path === "..") {
                            window.location.href = "/";
                            result = "Navigating to home...";
                        } else {
                            window.location.href = path;
                            result = `Navigating to ${path}...`;
                        }
                    } else {
                        result = `<span class="text-red-500">Path not found: ${path}</span>`;
                    }
                    break;
                case "about":
                    result = `
<div class="mb-2">
  <span class="text-white font-bold">Isaac Martinez</span>
  <br/>
  Software Architect & Full Stack Developer
</div>
<p class="mb-2 text-gray-300">
  ${this.aboutText}
</p>
<div>
  <span class="text-gray-400">Tech Stack:</span> Node.js, TypeScript, React, Astro, AWS, Docker.
</div>`;
                    break;
                case "projects":
                    result = this.projects
                        .map(
                            (p: any, i: number) => `
<div class="mb-2">
  <span class="text-white font-bold">${i + 1}. ${p.title}</span>
  <div class="pl-4 text-gray-400 text-sm">${p.description}</div>
  <div class="pl-4"><a href="${p.link}" target="_blank" class="text-[#00ccff] underline hover:text-white text-xs">View Project</a></div>
</div>`,
                        )
                        .join("");
                    break;
                case "contact":
                    result = `
<div class="grid grid-cols-[100px_1fr] gap-2">
  <span class="text-white">Email</span>    <a href="mailto:${this.contactInfo.email}" class="underline hover:text-white">${this.contactInfo.email}</a>
  <span class="text-white">GitHub</span>   <a href="https://${this.contactInfo.github}" target="_blank" class="underline hover:text-white">${this.contactInfo.github}</a>
  <span class="text-white">LinkedIn</span> <a href="https://${this.contactInfo.linkedin}" target="_blank" class="underline hover:text-white">${this.contactInfo.linkedin}</a>
  <span class="text-white">Location</span> <span>${this.contactInfo.location}</span>
</div>`;
                    break;
                case "clear":
                    if (this.output) this.output.innerHTML = "";
                    result = "";
                    break;
                case "exit":
                    this.closeTerminal();
                    result = "Closing session...";
                    break;
                case "download":
                    // Check if we are on the about page (localized)
                    if (window.location.pathname.includes("/about")) {
                        const btn = document.getElementById(
                            "download-resume-btn",
                        );
                        if (btn) {
                            result = "Initiating download sequence...";
                            btn.click();
                            setTimeout(() => this.minimizeTerminal(), 800);
                        } else {
                            result =
                                '<span class="text-red-500">Error: Download module not found.</span>';
                        }
                    } else {
                        result =
                            "Redirecting to secure channel for download...";
                        sessionStorage.setItem(
                            "trigger-resume-download",
                            "true",
                        );
                        setTimeout(() => this.minimizeTerminal(), 800);
                        setTimeout(() => {
                            window.location.href = "/about"; // or localized version if needed, but /about redirects usually
                        }, 1500);
                    }
                    break;
                case "game":
                    const arg = args[0]?.toLowerCase();
                    if (arg === "--help" || arg === "-h") {
                        result = `
<div class="mb-2">
  <span class="text-white font-bold">Snake Game Help</span>
</div>
<div class="grid grid-cols-[120px_1fr] gap-2 mb-2">
  <span class="text-[#00ccff]">Usage</span> <span>game [difficulty]</span>
  <span class="text-[#00ccff]">Difficulties</span> <span>easy, normal, difficult</span>
</div>
<div class="mb-2">
  <span class="text-gray-400">Controls:</span>
  <ul class="list-disc pl-5 text-sm text-gray-300">
    <li>Arrow Keys: Move Snake</li>
    <li>Ctrl+C / ESC: Cancel Game</li>
    <li>r: Retry (Game Over)</li>
    <li>q: Quit (Game Over)</li>
  </ul>
</div>`;
                    } else {
                        const difficulty = arg || "normal";
                        if (
                            ["easy", "normal", "difficult"].includes(difficulty)
                        ) {
                            this.startGame(
                                difficulty as "easy" | "normal" | "difficult",
                            );
                            return;
                        } else {
                            result = `<span class="text-yellow-500">Usage: game [easy|normal|difficult]</span><br>Starting normal mode...`;
                            setTimeout(() => this.startGame("normal"), 1500);
                            return;
                        }
                    }
                    break;
                case "matrix":
                    if (this.canvas?.classList.contains("hidden")) {
                        this.startMatrix();
                        result =
                            "Matrix effect enabled. Follow the white rabbit.";
                    } else {
                        this.stopMatrix();
                        result = "Matrix effect disabled.";
                    }
                    break;
                case "sudo":
                    result = `<span class="text-red-500">Permission denied: You are not root. Nice try though.</span>`;
                    break;
                default:
                    result = `<span class="text-red-400">Command not found: ${cmd}. Type 'help' for available commands.</span>`;
            }

            if (result !== undefined) {
                this.addToOutput(trimmed, result as string);
            }

            if (this.input) this.input.value = "";
            this.saveState();
        }

        // Snake Game Logic
        private gameInterval: any = null;
        private isGameActive = false;
        private isGameOver = false;
        private snake: { x: number; y: number }[] = [];
        private food: { x: number; y: number } = { x: 0, y: 0 };
        private direction: "UP" | "DOWN" | "LEFT" | "RIGHT" = "RIGHT";
        private nextDirection: "UP" | "DOWN" | "LEFT" | "RIGHT" = "RIGHT";
        private score = 0;
        private highScore = 0;
        private gameWidth = 40;
        private gameHeight = 20;
        private gameSpeed = 100;
        private gameDifficulty: "easy" | "normal" | "difficult" = "normal";

        private startGame(
            difficulty: "easy" | "normal" | "difficult" = "normal",
        ) {
            if (this.isGameActive) return;

            // Clear terminal for full immersion
            if (this.output) this.output.innerHTML = "";

            // Hide input line
            if (this.inputLine) this.inputLine.classList.add("hidden");

            this.isGameActive = true;
            this.isGameOver = false;
            this.score = 0;
            this.gameDifficulty = difficulty;
            this.highScore = parseInt(
                localStorage.getItem(`snake_highscore_${difficulty}`) || "0",
            );

            // Difficulty Settings
            switch (difficulty) {
                case "easy":
                    this.gameSpeed = 150;
                    break;
                case "normal":
                    this.gameSpeed = 100;
                    break;
                case "difficult":
                    this.gameSpeed = 60;
                    break;
            }

            this.snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 },
            ];
            this.direction = "RIGHT";
            this.nextDirection = "RIGHT";
            this.spawnFood();

            // Create Game Container
            const gameContainer = document.createElement("div");
            gameContainer.id = "snake-game";
            // Adjusted text size to be big but not overflow
            gameContainer.className =
                "font-mono leading-none my-4 select-none text-lg md:text-xl tracking-wider";
            gameContainer.style.whiteSpace = "pre";
            this.output?.appendChild(gameContainer);

            // We don't focus input here anymore as we use window listener
            // But we might want to blur it to avoid mobile keyboard
            this.input?.blur();

            this.gameInterval = setInterval(
                () => this.gameLoop(gameContainer),
                this.gameSpeed,
            );
        }

        private stopGame(reason: "collision" | "user" = "user") {
            if (!this.isGameActive) return;
            this.isGameActive = false;
            clearInterval(this.gameInterval);

            const gameContainer = this.output?.querySelector("#snake-game");
            if (gameContainer) {
                if (reason === "collision") {
                    this.isGameOver = true;
                    gameContainer.innerHTML += `\n\n<span class="text-red-500 font-bold">GAME OVER</span>\nScore: ${this.score} | High Score: ${this.highScore}\n<span class="text-gray-400">Press 'r' to retry, 'q' to quit</span>`;
                } else {
                    gameContainer.innerHTML += `\n\n<span class="text-yellow-500">Game Cancelled by User</span>`;
                    this.addToOutput("", `Game cancelled.`);
                    this.restorePrompt();
                }
            }

            if (this.score > this.highScore) {
                localStorage.setItem(
                    `snake_highscore_${this.gameDifficulty}`,
                    this.score.toString(),
                );
            }
        }

        private restorePrompt() {
            // Show input line again
            if (this.inputLine) this.inputLine.classList.remove("hidden");
            this.saveState();
            setTimeout(() => this.input?.focus(), 50);
        }

        private spawnFood() {
            let padding = 0;
            if (this.gameDifficulty === "easy") padding = 2;
            if (this.gameDifficulty === "normal") padding = 1;

            const minX = padding;
            const maxX = this.gameWidth - padding;
            const minY = padding;
            const maxY = this.gameHeight - padding;

            this.food = {
                x: Math.floor(Math.random() * (maxX - minX)) + minX,
                y: Math.floor(Math.random() * (maxY - minY)) + minY,
            };

            // Ensure food doesn't spawn on snake
            if (
                this.snake.some(
                    (segment) =>
                        segment.x === this.food.x && segment.y === this.food.y,
                )
            ) {
                this.spawnFood();
            }
        }

        private gameLoop(container: HTMLElement) {
            this.direction = this.nextDirection;
            const head = { ...this.snake[0] };

            switch (this.direction) {
                case "UP":
                    head.y--;
                    break;
                case "DOWN":
                    head.y++;
                    break;
                case "LEFT":
                    head.x--;
                    break;
                case "RIGHT":
                    head.x++;
                    break;
            }

            // Check Collision (Walls)
            if (
                head.x < 0 ||
                head.x >= this.gameWidth ||
                head.y < 0 ||
                head.y >= this.gameHeight
            ) {
                this.stopGame("collision");
                return;
            }

            // Check Collision (Self)
            if (
                this.snake.some(
                    (segment) => segment.x === head.x && segment.y === head.y,
                )
            ) {
                this.stopGame("collision");
                return;
            }

            this.snake.unshift(head);

            // Check Food
            if (head.x === this.food.x && head.y === this.food.y) {
                this.score += 10;

                // Speed up logic
                if (this.gameDifficulty === "easy")
                    this.gameSpeed = Math.max(100, this.gameSpeed - 1);
                if (this.gameDifficulty === "normal")
                    this.gameSpeed = Math.max(50, this.gameSpeed - 2);
                if (this.gameDifficulty === "difficult")
                    this.gameSpeed = Math.max(30, this.gameSpeed - 4);

                clearInterval(this.gameInterval);
                this.gameInterval = setInterval(
                    () => this.gameLoop(container),
                    this.gameSpeed,
                );

                this.spawnFood();
            } else {
                this.snake.pop();
            }

            // Render
            this.renderGame(container);
        }

        private renderGame(container: HTMLElement) {
            let grid = "";
            // Top Border
            grid += "+" + "-".repeat(this.gameWidth) + "+\n";

            for (let y = 0; y < this.gameHeight; y++) {
                grid += "|";
                for (let x = 0; x < this.gameWidth; x++) {
                    if (this.snake[0].x === x && this.snake[0].y === y) {
                        grid += '<span class="text-green-500">O</span>'; // Head
                    } else if (this.snake.some((s) => s.x === x && s.y === y)) {
                        grid += '<span class="text-green-700">o</span>'; // Body
                    } else if (this.food.x === x && this.food.y === y) {
                        grid += '<span class="text-red-500">*</span>'; // Food
                    } else {
                        grid += '<span class="text-gray-800">.</span>'; // Empty
                    }
                }
                grid += "|\n";
            }

            // Bottom Border
            grid += "+" + "-".repeat(this.gameWidth) + "+";
            grid += `\nScore: ${this.score} | High Score: ${Math.max(this.score, this.highScore)} | Mode: ${this.gameDifficulty.toUpperCase()}`;

            container.innerHTML = grid;
            if (this.content)
                this.content.scrollTop = this.content.scrollHeight;
        }
        private addToOutput(cmd: string, result: string) {
            if (!this.output) return;

            const cmdLine = document.createElement("div");
            cmdLine.className = "mb-1";
            cmdLine.innerHTML = `<span class="text-[#33ff00]">➜</span> <span class="text-[#00ccff]">~</span> <span class="text-white">${cmd}</span>`;
            this.output.appendChild(cmdLine);

            if (result) {
                const resultLine = document.createElement("div");
                resultLine.className = "mb-4 text-gray-300";
                resultLine.innerHTML = result;
                this.output.appendChild(resultLine);
            }

            if (this.content)
                this.content.scrollTop = this.content.scrollHeight;
        }

        private startMatrix() {
            if (!this.canvas) return;
            this.canvas.classList.remove("hidden");
            const ctx = this.canvas.getContext("2d");
            if (!ctx) return;

            this.canvas.width = this.windowEl?.offsetWidth || 800;
            this.canvas.height = this.windowEl?.offsetHeight || 600;

            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%";
            const fontSize = 14;
            const columns = this.canvas.width / fontSize;
            const drops: number[] = [];

            for (let i = 0; i < columns; i++) {
                drops[i] = 1;
            }

            const draw = () => {
                if (!ctx || !this.canvas) return;
                ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                ctx.fillStyle = "#0F0";
                ctx.font = fontSize + "px monospace";

                for (let i = 0; i < drops.length; i++) {
                    const text = letters.charAt(
                        Math.floor(Math.random() * letters.length),
                    );
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                    if (
                        drops[i] * fontSize > this.canvas.height &&
                        Math.random() > 0.975
                    ) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            };

            this.matrixInterval = setInterval(draw, 33);
        }

        private stopMatrix() {
            if (!this.canvas) return;
            this.canvas.classList.add("hidden");
            if (this.matrixInterval) {
                clearInterval(this.matrixInterval);
                this.matrixInterval = null;
            }
        }

        private handleResize() {
            if (!this.canvas?.classList.contains("hidden")) {
                this.stopMatrix();
                this.startMatrix();
            }
        }
    }

    // Register the custom element
    if (!customElements.get("terminal-window")) {
        customElements.define("terminal-window", TerminalWindow);
    }
</script>
